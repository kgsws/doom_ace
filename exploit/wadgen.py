#!/usr/bin/python3

import sys
import os

from collections import OrderedDict
from struct import pack
from struct import unpack_from
from struct import pack_into

# special lump
data_pnames = b"\x01\x00\x00\x00" + b"ACE_LDR0"

# primitive WAD file stuff
class kgWadFile:
        lump = OrderedDict()
        verbose = True

        def lumpFromBuff(self, lumpname, data):
                size = len(data)
                lmp = {}
                lmp["size"] = size
                padsize = size + 3
                padsize &= ~3
                lmp["padsize"] = padsize
                lmp["data"] = bytes(data) + b"\x00" * (padsize - size)
                self.lump[lumpname] = lmp
                if self.verbose:
                        print("added", lumpname, ",", size, "B")

        def lumpFromFile(self, lumpname, filename):
                with open(filename, "rb") as f:
                        contents = f.read()
                self.lumpFromBuff(lumpname, contents)

        def saveFile(self, filename):
                if self.verbose:
                        print("saving", len(self.lump), "entries")

                with open(filename, "wb") as f:
                        dir_offset = 12
                        
                        # WAD header.
                        data = pack("<III", 0x44415750, len(self.lump), dir_offset)
                        f.write(data)

                        file_offset = dir_offset + 16 * len(self.lump)

                        # Files.
                        for key in self.lump:
                                data = pack("<II", file_offset, self.lump[key]["size"])
                                f.write(data)
                                
                                data = bytearray(8)
                                pack_into("8s", data, 0, key.encode('utf-8'))
                                f.write(data)

                                file_offset += self.lump[key]["padsize"]
                                
                        # Data.
                        for key in self.lump:
                                f.write(self.lump[key]["data"])

# convert binary to special Doom 'patch'
def convert_code(filename):
        # load the file
        with open(filename, "rb") as f:
                code = bytearray()
                code += f.read()

        print("code size", len(code), "B")

        if len(code) > 256:
                raise Exception("Loader 0 size is too big!")

        # generate output
        ret = bytearray(688)
        index = 0

        # header
        pack_into("<Q", ret, 0, 0x80)
        index += 8

        # contents
        for i in range(0,len(code)//2):
                value, = unpack_from("<H", code, i * 2)
                value += 0x10000
                value -= 3
                value &= 0xFFFF
                pack_into("<I", ret, index, value)
                index += 4

        return ret

# check arguments
if len(sys.argv) != 4:
        print("usage:", sys.argv[0], "loader0.bin loader1.bin output.wad")
        exit(1)

loader0 = convert_code(sys.argv[1])

# create WAD file
wadfile = kgWadFile()
wadfile.lumpFromFile("ACE_CODE", "../engine/code.lmp")
wadfile.lumpFromBuff("ACE_LDR0", loader0)
wadfile.lumpFromFile("ACE_LDR1", sys.argv[2])
wadfile.lumpFromBuff("PNAMES", data_pnames)
wadfile.lumpFromFile("TEXTURE1", "texture1.lmp")

ACE_CONF_PATH = "../ACE_CONF.conf"

if os.path.exists(ACE_CONF_PATH):
        print("Including our own copy of ACE_CONF lump into the WAD")
        wadfile.lumpFromFile("ACE_CONF", ACE_CONF_PATH)
else:
        print("Skipping ACE_CONF lump since it doesn't exist")

# done
wadfile.saveFile(sys.argv[3])
